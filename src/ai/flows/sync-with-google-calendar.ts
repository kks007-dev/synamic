
'use server';

/**
 * @fileOverview An AI agent that syncs a generated schedule with Google Calendar.
 * 
 * - syncWithGoogleCalendar - A function that handles the Google Calendar sync process.
 * - SyncWithGoogleCalendarInput - The input type for the syncWithGoogleCalendar function.
 * - SyncWithGoogleCalendarOutput - The return type for the syncWithGoogleCalendar function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import {parse, format} from 'date-fns';
import { google } from 'googleapis';
import { toZonedTime } from 'date-fns-tz';
// Remove: import { auth } from '@/lib/firebase-admin';

// Helper to create a new calendar and return its ID
async function createNewCalendar(accessToken: string): Promise<string | null> {
    try {
        const oAuth2Client = new google.auth.OAuth2();
        oAuth2Client.setCredentials({ access_token: accessToken });
        const calendar = google.calendar({ version: 'v3', auth: oAuth2Client });
        const res = await calendar.calendars.insert({
            requestBody: {
                summary: "Synamic AI Schedule",
                description: "Schedule generated by Synamic AI",
                timeZone: "UTC",
            },
        });
        return res.data.id || null;
    } catch (error: any) {
        console.error('Error creating Google Calendar:', error);
        return null;
    }
}

// This tool represents the action of creating an event in a user's Google Calendar.
async function createCalendarEvent({ calendarId, title, startTime, endTime, accessToken, timeZone }: { calendarId: string, title: string, startTime: string, endTime: string, accessToken: string, timeZone: string }) {
    try {
        const oAuth2Client = new google.auth.OAuth2();
        oAuth2Client.setCredentials({ access_token: accessToken });
        const calendar = google.calendar({ version: 'v3', auth: oAuth2Client });
        const res = await calendar.events.insert({
            calendarId,
            requestBody: {
                summary: title,
                start: { dateTime: startTime, timeZone },
                end: { dateTime: endTime, timeZone },
            },
        });
        return { success: true, eventId: res.data.id };
    } catch (error: any) {
        console.error('Error creating Google Calendar event:', error);
        return { success: false };
    }
}

const EventSchema = z.object({
    title: z.string(),
    startTime: z.string(),
    endTime: z.string(),
});

// Accept accessToken instead of idToken
const SyncWithGoogleCalendarInputSchema = z.object({
    events: z.array(EventSchema).describe("A list of events to be synced to the calendar."),
    accessToken: z.string().describe("The user's Google OAuth access token for authorization."),
    targetDates: z.array(z.string()).optional().describe("Array of YYYY-MM-DD dates to sync the schedule to."),
});
export type SyncWithGoogleCalendarInput = z.infer<typeof SyncWithGoogleCalendarInputSchema>;

const SyncWithGoogleCalendarOutputSchema = z.object({
    syncedEvents: z.array(z.object({
        title: z.string(),
        startTime: z.string(),
        endTime: z.string(),
        eventId: z.string().optional(),
    })).describe('A list of events that were successfully synced.'),
    errors: z.array(z.string()).describe('Any errors that occurred during the sync process.'),
});
export type SyncWithGoogleCalendarOutput = z.infer<typeof SyncWithGoogleCalendarOutputSchema>;

export async function syncWithGoogleCalendar(input: SyncWithGoogleCalendarInput): Promise<SyncWithGoogleCalendarOutput> {
    return syncWithGoogleCalendarFlow(input);
}


function convertToISO(timeStr: string): string {
    const now = new Date();
    // Use date-fns to parse the "h:mm a" format robustly
    const date = parse(timeStr, 'h:mm a', now);
    return date.toISOString();
}

// Helper to read events for a given date and calendar
async function getEventsForDate({
    calendarId,
    date,
    accessToken,
}: {
    calendarId: string;
    date: string;
    accessToken: string;
}) {
    if (!calendarId || !date || !accessToken) {
        throw new Error("Missing required parameters for getEventsForDate");
    }
    const oAuth2Client = new google.auth.OAuth2();
    oAuth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: 'v3', auth: oAuth2Client });
    // Ensure date is in YYYY-MM-DD format
    const dateObj = new Date(date);
    if (isNaN(dateObj.getTime())) {
        throw new Error("Invalid date format for getEventsForDate");
    }
    const timeMin = new Date(date + 'T00:00:00').toISOString();
    const timeMax = new Date(date + 'T23:59:59').toISOString();
    const res = await calendar.events.list({
        calendarId,
        timeMin,
        timeMax,
        singleEvents: true,
        orderBy: 'startTime',
    });
    return res.data.items || [];
}

// Fetch events from all calendars for a given date
async function getAllEventsForDate({ date, accessToken }: { date: string; accessToken: string; }) {
    if (!date || !accessToken) {
        throw new Error("Missing required parameters for getAllEventsForDate");
    }
    const oAuth2Client = new google.auth.OAuth2();
    oAuth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: 'v3', auth: oAuth2Client });
    // Get all calendars
    const calendarList = await calendar.calendarList.list();
    const calendars = calendarList.data.items || [];
    // Debug: log all calendar summaries and IDs
    console.log('Fetching events from calendars:', calendars.map(c => ({ summary: c.summary, id: c.id })));
    const allEvents = [];
    for (const cal of calendars) {
        if (!cal.id) continue;
        // No filter: include all calendars, including 'Synamic AI Schedule'
        const timeMin = new Date(date + 'T00:00:00').toISOString();
        const timeMax = new Date(date + 'T23:59:59').toISOString();
        const res = await calendar.events.list({
            calendarId: cal.id,
            timeMin,
            timeMax,
            singleEvents: true,
            orderBy: 'startTime',
        });
        if (res.data.items) {
            allEvents.push(...res.data.items.map(e => ({ ...e, calendarId: cal.id, calendarSummary: cal.summary })));
        }
    }
    return allEvents;
}

function combineDateAndTime(dateStr: string, timeStr: string, timeZone: string): { start: string; end: string } | null {
    // dateStr: 'YYYY-MM-DD', timeStr: '1:00 PM' or '1:00 PM - 2:00 PM'
    if (!dateStr || !timeStr) return null;
    const [start, end] = timeStr.split('-').map((s: string) => s.trim());
    function toUTCISOStringAggressive(t: string): string {
        const [time, ampm] = t.split(' ');
        let [h, m] = time.split(':');
        let hour = parseInt(h, 10);
        let minute = parseInt(m, 10);
        if (ampm.toUpperCase() === 'PM' && hour < 12) hour += 12;
        if (ampm.toUpperCase() === 'AM' && hour === 12) hour = 0;
        // Construct a date string in the user's local time zone
        const localDateStr = `${dateStr}T${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`;
        // Convert to the specified time zone, then to UTC
        const zoned = toZonedTime(localDateStr, timeZone);
        return new Date(zoned).toISOString();
    }
    return { start: toUTCISOStringAggressive(start), end: toUTCISOStringAggressive(end) };
}

// Helper to find or create the Synamic AI Schedule calendar
async function getOrCreateSynamicCalendar(accessToken: string): Promise<string | null> {
    const oAuth2Client = new google.auth.OAuth2();
    oAuth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: 'v3', auth: oAuth2Client });
    // 1. Try to find existing calendar
    const list = await calendar.calendarList.list();
    const existing = list.data.items?.find(cal => cal.summary === 'Synamic AI Schedule');
    if (existing && existing.id) return existing.id;
    // 2. If not found, create new
    const res = await calendar.calendars.insert({
        requestBody: {
            summary: "Synamic AI Schedule",
            description: "Schedule generated by Synamic AI",
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
        },
    });
    return res.data.id || null;
}

const syncWithGoogleCalendarFlow = ai.defineFlow(
    {
        name: 'syncWithGoogleCalendarFlow',
        inputSchema: SyncWithGoogleCalendarInputSchema,
        outputSchema: SyncWithGoogleCalendarOutputSchema,
    },
    async (input) => {
        const syncedEvents: any[] = [];
        const errors: string[] = [];

        if (!input.accessToken) {
            errors.push("No Google access token provided. Please sign in with Google.");
            return { syncedEvents, errors };
        }

        // 1. Find or create the Synamic AI Schedule calendar
        const calendarId = await getOrCreateSynamicCalendar(input.accessToken);
        if (!calendarId) {
            errors.push("Failed to find or create the Synamic AI Schedule calendar.");
            return { syncedEvents, errors };
        }

        // Use user's local time zone for Google Calendar event metadata
        const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
        const targetDates = input.targetDates || [new Date().toISOString().slice(0, 10)];
        for (const date of targetDates) {
            // 1. Read existing events for this date
            const existingEvents = await getAllEventsForDate({ date, accessToken: input.accessToken });
            for (const event of input.events) {
                const combined = combineDateAndTime(date, event.startTime + ' - ' + event.endTime, userTimeZone);
                if (!combined) continue;
                const { start, end } = combined;
                // Check for duplicate by title and start time
                const duplicate = existingEvents.find((e: any) => e.summary === event.title && e.start?.dateTime?.slice(0,16) === start.slice(0,16));
                if (duplicate) continue; // Skip duplicate
                const result = await createCalendarEvent({
                    calendarId,
                    title: event.title,
                    startTime: start,
                    endTime: end,
                    accessToken: input.accessToken,
                    timeZone: userTimeZone,
                });
                if (result.success) {
                    syncedEvents.push({
                        title: event.title,
                        startTime: start,
                        endTime: end,
                        eventId: result.eventId,
                    });
                }
            }
        }
        return {
            syncedEvents,
            errors,
        };
    }
);
